# Python Bindings

A unified project that contains multiple implementations of C/C++ functions exported as modules into Python.

The repository is organized in smaller projects, where each project implements a Python module with `C++` that does a specific task (e.g. return a string, return the current time and so on).  A project can have a module with multiple methods, if they are defined in their respective `C++` source code.

An individual project has some core parts which are consistent across the entire repository's internal structure. Namely, each sub project has:

* a main `C++` file which contains the actual methods that should be embedded into Python. (usually the name is `sub-project-name.cc`).
  * This source file basically contains all the `PyObject` methods that implement a specific functionality.
* a main header file which initializes the created methods into a Module, that must be exported into Python.
  * The header file must have the methods embedded into a module compatible with both `python@2` and also `python@3`.
  * This is done by creating a general `IF` condition, where compiler checks at build time what `python` interpreter has been selected (e.g. `/usr/bin/python2` or `/usr/bin/python3`).
  * More details about **generating python modules with `C/C++`** can be read [here](docs.md).
  * name of the header must be `sub-project-name.hh`
* a `setup.py` script, which is used to **build** the source code into working python modules.
  * The script is based on  `from distutils.core import setup, Extension` which is used for building extensions for python.
  * **Obs**: if the `C/C++` source code has implementations that take advantage of the C++11 and C++14 standards, extra compile flags must be added into the setup script in order to avoid potential *errors* and *warnings* (however, this depends on the C++ compiler,  the python interpreter itself but also on the platform that the project is built). More on that in the [documentation](docs.md).
* a small project description, named `about.md` that explains what the sub-project does.
* a script for deleting any potential executable (`a.out`) generated by compiling the `C/C++` source code but also any content from the directory in which the python extensions are built into.
  * check for  `wipebuild.sh` script in each project main directory.
  * usually the built extension are placed into the main project's tree, in a `build/` subdirectory.
* a short and simple python file that just imports the specific module freshly created, and then tests its methods. (must be named `test.py`).
* A second shell script, namely `build.sh`, that has multiple stages:
  1. It checks if there are previous built extensions into the main tree, and if true, deletes them.
  2. Starts a build pipeline for **Python2** and proceeds to `cd` into the location of the obtained `.so` library.
  3. Once inside the corresponding shared library's source directory, it copies the python test file `test.py` next to the library, and finally it executed the python script.
  4. Another similar pipeline is started, but for **Python3**, following the same procedures.

**Update** - introduced a new script that detects the platform on which the project is built&executed.
TO-DO

- [ ] documentation for `check-os.sh`

## Resources

1. [Extending Python with C or C++](https://docs.python.org/2/extending/extending.html#a-simple-example) - Useful guide on configuring an extension with Python2.
2. [Python Module Objects](https://docs.python.org/3/c-api/module.html#initializing-modules)
3. [Building C and C++ Extensions](https://docs.python.org/3/extending/building.html#c.PyInit_modulename)
4. [C extension not working in Python 3.7 says ImportError: dynamic module does not define module export function (PyInit_loop)](https://stackoverflow.com/questions/57214046/c-extension-not-working-in-python-3-7-says-importerror-dynamic-module-does-not)  - discussion on how to declare an init function for python3
5. [PyInit_modulename](https://docs.python.org/3/extending/building.html#c.PyInit_modulename) - Official documentation on building the init functions.
